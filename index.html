<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Bulk Video Auto-Editor</title>
    <style>
        :root {
            --primary: #5c6bc0;
            --secondary: #78909c;
            --success: #66bb6a;
            --danger: #ef5350;
            --warning: #ffa726;
            --dark: #37474f;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f5f7fa;
            color: #263238;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 30px;
            overflow: hidden;
        }
        h1 {
            color: var(--primary);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        h1 i {
            margin-right: 15px;
        }
        .subtitle {
            color: var(--secondary);
            margin-bottom: 30px;
        }
        .upload-area {
            border: 2px dashed #cfd8dc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            background-color: #fafafa;
            transition: all 0.3s;
            position: relative;
        }
        .upload-area.highlight {
            border-color: var(--primary);
            background-color: #e8eaf6;
        }
        #fileInput {
            display: none;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .btn-primary {
            background-color: var(--primary);
            color: white;
        }
        .btn-primary:hover {
            background-color: #3949ab;
        }
        .btn-primary:disabled {
            background-color: #9fa8da;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: var(--secondary);
            color: white;
        }
        .btn-secondary:hover {
            background-color: #546e7a;
        }
        .batch-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        .batch-info {
            background-color: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            display: none;
        }
        .batch-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .stat-value {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .stat-label {
            font-size: 13px;
            color: var(--secondary);
        }
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .video-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            transition: transform 0.2s;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .video-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .video-preview {
            position: relative;
            background: #000;
        }
        .video-preview video {
            width: 100%;
            height: 160px;
            object-fit: contain;
        }
        .video-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .video-info {
            padding: 15px;
        }
        .video-name {
            font-weight: 500;
            margin-bottom: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .video-status {
            display: flex;
            align-items: center;
            font-size: 14px;
            margin-bottom: 10px;
        }
        .status-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-queued {
            background-color: var(--secondary);
        }
        .status-processing {
            background-color: var(--warning);
            animation: pulse 1.5s infinite;
        }
        .status-completed {
            background-color: var(--success);
        }
        .status-failed {
            background-color: var(--danger);
        }
        .progress-container {
            margin-top: 10px;
            height: 6px;
            background: #eceff1;
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s;
        }
        .video-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        .video-actions .btn {
            padding: 6px 12px;
            font-size: 13px;
            flex: 1;
            justify-content: center;
        }
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            display: none;
        }
        .processing-content {
            background: white;
            color: var(--dark);
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        .spinner {
            border: 4px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top: 4px solid var(--primary);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .options-panel {
            background: #f5f7fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
        }
        .option-group {
            margin-bottom: 20px;
        }
        .option-title {
            font-weight: 500;
            margin-bottom: 12px;
            color: var(--dark);
            display: flex;
            align-items: center;
        }
        .option-title i {
            margin-right: 10px;
            color: var(--primary);
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container label {
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
        }
        .slider-value {
            float: right;
            font-weight: 500;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #cfd8dc;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
        }
        .checkbox-item input {
            margin-right: 8px;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <h1><i class="fas fa-video"></i> AI Bulk Video Auto-Editor</h1>
        <p class="subtitle">Process 1-100 videos simultaneously with AI-powered auto-editing</p>
        
        <div class="options-panel">
            <div class="option-group">
                <div class="option-title"><i class="fas fa-cut"></i> Editing Options</div>
                <div class="slider-container">
                    <label>Silence Threshold: <span class="slider-value" id="silenceValue">0.5</span></label>
                    <input type="range" id="silenceThreshold" min="0.1" max="1" step="0.1" value="0.5">
                </div>
                <div class="slider-container">
                    <label>Minimum Clip Duration (s): <span class="slider-value" id="minDurationValue">2</span></label>
                    <input type="range" id="minDuration" min="1" max="10" step="1" value="2">
                </div>
                <div class="checkbox-group">
                    <label class="checkbox-item">
                        <input type="checkbox" id="removeSilence" checked> Remove silent sections
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="removeStatic" checked> Remove static scenes
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="autoPacing" checked> Auto-adjust pacing
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="autoCrop" checked> Auto-crop and zoom
                    </label>
                </div>
            </div>
            
            <div class="option-group">
                <div class="option-title"><i class="fas fa-magic"></i> AI Enhancements</div>
                <div class="checkbox-group">
                    <label class="checkbox-item">
                        <input type="checkbox" id="stabilize" checked> Stabilize shaky footage
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="colorCorrect" checked> Auto color correction
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="autoVolume" checked> Normalize audio
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="faceFocus" checked> Auto-face focus
                    </label>
                </div>
            </div>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <i class="fas fa-cloud-upload-alt" style="font-size: 48px; color: var(--primary); margin-bottom: 15px;"></i>
            <h3>Drag & Drop Video Files Here</h3>
            <p>or click to browse files (supports 1-100 videos at once)</p>
            <input type="file" id="fileInput" multiple accept="video/*">
            <button class="btn btn-secondary" onclick="document.getElementById('fileInput').click()">
                <i class="fas fa-folder-open"></i> Select Videos
            </button>
        </div>
        
        <div class="batch-info" id="batchInfo">
            <h3>Batch Processing</h3>
            <div class="batch-stats">
                <div class="stat-card">
                    <div class="stat-value" id="totalFiles">0</div>
                    <div class="stat-label">Total Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="processedFiles">0</div>
                    <div class="stat-label">Processed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="successFiles">0</div>
                    <div class="stat-label">Success</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="failedFiles">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="remainingFiles">0</div>
                    <div class="stat-label">Remaining</div>
                </div>
            </div>
        </div>
        
        <div class="batch-controls">
            <button class="btn btn-primary" id="processAllBtn" disabled>
                <i class="fas fa-play"></i> Process All Videos
            </button>
            <button class="btn btn-secondary" id="cancelAllBtn" disabled>
                <i class="fas fa-stop"></i> Cancel Processing
            </button>
            <button class="btn btn-secondary" id="downloadAllBtn" disabled>
                <i class="fas fa-download"></i> Download All
            </button>
        </div>
        
        <div class="video-grid" id="videoGrid"></div>
    </div>
    
    <div class="processing-overlay" id="processingOverlay">
        <div class="processing-content">
            <div class="spinner"></div>
            <h3 id="processingTitle">Processing Videos</h3>
            <p id="processingText">Initializing batch processing...</p>
            <div class="progress-container" style="width: 100%; margin-top: 20px;">
                <div class="progress-bar" id="globalProgressBar"></div>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                <span id="processedCount">0 processed</span>
                <span id="remainingCount">0 remaining</span>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const processAllBtn = document.getElementById('processAllBtn');
        const cancelAllBtn = document.getElementById('cancelAllBtn');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const videoGrid = document.getElementById('videoGrid');
        const batchInfo = document.getElementById('batchInfo');
        const totalFilesEl = document.getElementById('totalFiles');
        const processedFilesEl = document.getElementById('processedFiles');
        const successFilesEl = document.getElementById('successFiles');
        const failedFilesEl = document.getElementById('failedFiles');
        const remainingFilesEl = document.getElementById('remainingFiles');
        const processingOverlay = document.getElementById('processingOverlay');
        const processingTitle = document.getElementById('processingTitle');
        const processingText = document.getElementById('processingText');
        const globalProgressBar = document.getElementById('globalProgressBar');
        const processedCountEl = document.getElementById('processedCount');
        const remainingCountEl = document.getElementById('remainingCount');
        
        // Options Elements
        const silenceThreshold = document.getElementById('silenceThreshold');
        const minDuration = document.getElementById('minDuration');
        const silenceValue = document.getElementById('silenceValue');
        const minDurationValue = document.getElementById('minDurationValue');
        const removeSilence = document.getElementById('removeSilence');
        const removeStatic = document.getElementById('removeStatic');
        const autoPacing = document.getElementById('autoPacing');
        const autoCrop = document.getElementById('autoCrop');
        const stabilize = document.getElementById('stabilize');
        const colorCorrect = document.getElementById('colorCorrect');
        const autoVolume = document.getElementById('autoVolume');
        const faceFocus = document.getElementById('faceFocus');
        
        // State Variables
        let videoFiles = [];
        let processing = false;
        let cancelRequested = false;
        let processedVideos = [];
        
        // Event Listeners
        fileInput.addEventListener('change', handleFileSelection);
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        uploadArea.addEventListener('drop', handleDrop);
        processAllBtn.addEventListener('click', startBatchProcessing);
        cancelAllBtn.addEventListener('click', cancelProcessing);
        downloadAllBtn.addEventListener('click', downloadAllProcessed);
        
        silenceThreshold.addEventListener('input', () => {
            silenceValue.textContent = silenceThreshold.value;
        });
        
        minDuration.addEventListener('input', () => {
            minDurationValue.textContent = minDuration.value;
        });
        
        // Functions
        function handleFileSelection(e) {
            const files = Array.from(e.target.files).slice(0, 100);
            if (files.length > 0) {
                handleFiles(files);
            }
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('highlight');
        }
        
        function handleDragLeave() {
            uploadArea.classList.remove('highlight');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('highlight');
            
            const files = Array.from(e.dataTransfer.files)
                .filter(file => file.type.startsWith('video/'))
                .slice(0, 100);
                
            if (files.length > 0) {
                handleFiles(files);
            }
        }
        
        function handleFiles(files) {
            videoFiles = files;
            processedVideos = [];
            
            // Update batch info
            totalFilesEl.textContent = files.length;
            processedFilesEl.textContent = '0';
            successFilesEl.textContent = '0';
            failedFilesEl.textContent = '0';
            remainingFilesEl.textContent = files.length;
            
            // Enable/disable buttons
            processAllBtn.disabled = files.length === 0;
            downloadAllBtn.disabled = true;
            cancelAllBtn.disabled = true;
            
            // Clear previous grid
            videoGrid.innerHTML = '';
            
            // Create video cards
            files.forEach((file, index) => {
                createVideoCard(file, index);
            });
            
            batchInfo.style.display = 'block';
        }
        
        function createVideoCard(file, index) {
            const card = document.createElement('div');
            card.className = 'video-card';
            card.id = `video-${index}`;
            
            const preview = document.createElement('div');
            preview.className = 'video-preview';
            
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.controls = true;
            
            const badge = document.createElement('div');
            badge.className = 'video-badge';
            badge.textContent = `${(file.size / (1024 * 1024)).toFixed(1)}MB`;
            
            const info = document.createElement('div');
            info.className = 'video-info';
            
            const name = document.createElement('div');
            name.className = 'video-name';
            name.textContent = file.name;
            
            const status = document.createElement('div');
            status.className = 'video-status';
            
            const statusIcon = document.createElement('div');
            statusIcon.className = 'status-icon status-queued';
            
            const statusText = document.createElement('span');
            statusText.textContent = 'Queued';
            
            const progressContainer = document.createElement('div');
            progressContainer.className = 'progress-container';
            
            const progressBar = document.createElement('div');
            progressBar.className = 'progress-bar';
            progressBar.id = `progress-${index}`;
            
            const actions = document.createElement('div');
            actions.className = 'video-actions';
            
            const processBtn = document.createElement('button');
            processBtn.className = 'btn btn-primary';
            processBtn.innerHTML = '<i class="fas fa-cog"></i> Process';
            processBtn.onclick = () => processSingleVideo(index);
            
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'btn btn-secondary';
            downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download';
            downloadBtn.disabled = true;
            downloadBtn.id = `download-${index}`;
            
            // Build the card
            status.appendChild(statusIcon);
            status.appendChild(statusText);
            progressContainer.appendChild(progressBar);
            actions.appendChild(processBtn);
            actions.appendChild(downloadBtn);
            
            preview.appendChild(video);
            preview.appendChild(badge);
            
            info.appendChild(name);
            info.appendChild(status);
            info.appendChild(progressContainer);
            info.appendChild(actions);
            
            card.appendChild(preview);
            card.appendChild(info);
            
            videoGrid.appendChild(card);
        }
        
        async function startBatchProcessing() {
            if (videoFiles.length === 0 || processing) return;
            
            processing = true;
            cancelRequested = false;
            processAllBtn.disabled = true;
            cancelAllBtn.disabled = false;
            
            // Reset processed videos array
            processedVideos = [];
            
            // Show processing overlay
            processingOverlay.style.display = 'flex';
            processingTitle.textContent = `Processing ${videoFiles.length} Videos`;
            
            // Process each video sequentially (in real app could be parallel with limits)
            for (let i = 0; i < videoFiles.length; i++) {
                if (cancelRequested) break;
                
                const file = videoFiles[i];
                
                // Update UI
                processingText.textContent = `Processing: ${file.name}`;
                globalProgressBar.style.width = `${(i / videoFiles.length) * 100}%`;
                processedCountEl.textContent = `${i} processed`;
                remainingCountEl.textContent = `${videoFiles.length - i} remaining`;
                
                // Update video card
                updateVideoCardStatus(i, 'processing', 0);
                
                try {
                    // Simulate processing (in real app this would be API call)
                    const result = await simulateVideoProcessing(file, i);
                    
                    if (result.success) {
                        // Update video card with success
                        updateVideoCardStatus(i, 'completed', 100);
                        
                        // Enable download button
                        const downloadBtn = document.getElementById(`download-${i}`);
                        if (downloadBtn) {
                            downloadBtn.disabled = false;
                            downloadBtn.onclick = () => {
                                downloadProcessedVideo(result.processedBlob, file.name);
                            };
                        }
                        
                        // Add to processed videos
                        processedVideos.push({
                            index: i,
                            name: file.name,
                            blob: result.processedBlob
                        });
                        
                        // Update counters
                        successFilesEl.textContent = processedVideos.length;
                    } else {
                        // Update video card with failure
                        updateVideoCardStatus(i, 'failed', 0);
                        failedFilesEl.textContent = parseInt(failedFilesEl.textContent) + 1;
                    }
                    
                } catch (error) {
                    console.error(`Error processing video ${file.name}:`, error);
                    updateVideoCardStatus(i, 'failed', 0);
                    failedFilesEl.textContent = parseInt(failedFilesEl.textContent) + 1;
                }
                
                // Update counters
                processedFilesEl.textContent = i + 1;
                remainingFilesEl.textContent = videoFiles.length - (i + 1);
            }
            
            // Processing complete
            processing = false;
            cancelAllBtn.disabled = true;
            
            if (cancelRequested) {
                processingText.textContent = 'Processing canceled';
            } else {
                processingText.textContent = 'Batch processing complete!';
                globalProgressBar.style.width = '100%';
                
                // Enable download all button if we have processed videos
                if (processedVideos.length > 0) {
                    downloadAllBtn.disabled = false;
                }
            }
            
            // Hide overlay after delay
            setTimeout(() => {
                processingOverlay.style.display = 'none';
                processAllBtn.disabled = false;
            }, 2000);
        }
        
        function updateVideoCardStatus(index, status, progress) {
            const card = document.getElementById(`video-${index}`);
            if (!card) return;
            
            const statusEl = card.querySelector('.video-status');
            const statusIcon = card.querySelector('.status-icon');
            const statusText = card.querySelector('.video-status span');
            const progressBar = card.querySelector('.progress-bar');
            
            // Reset all status classes
            statusIcon.className = 'status-icon';
            
            switch (status) {
                case 'queued':
                    statusIcon.classList.add('status-queued');
                    statusText.textContent = 'Queued';
                    break;
                case 'processing':
                    statusIcon.classList.add('status-processing');
                    statusText.textContent = 'Processing...';
                    break;
                case 'completed':
                    statusIcon.classList.add('status-completed');
                    statusText.textContent = 'Completed';
                    break;
                case 'failed':
                    statusIcon.classList.add('status-failed');
                    statusText.textContent = 'Failed';
                    break;
            }
            
            progressBar.style.width = `${progress}%`;
        }
        
        function cancelProcessing() {
            cancelRequested = true;
            cancelAllBtn.disabled = true;
            processingText.textContent = 'Canceling...';
        }
        
        async function processSingleVideo(index) {
            if (index < 0 || index >= videoFiles.length || processing) return;
            
            const file = videoFiles[index];
            
            // Update video card
            updateVideoCardStatus(index, 'processing', 0);
            
            try {
                // Simulate processing (in real app this would be API call)
                const result = await simulateVideoProcessing(file, index);
                
                if (result.success) {
                    // Update video card with success
                    updateVideoCardStatus(index, 'completed', 100);
                    
                    // Enable download button
                    const downloadBtn = document.getElementById(`download-${index}`);
                    if (downloadBtn) {
                        downloadBtn.disabled = false;
                        downloadBtn.onclick = () => {
                            downloadProcessedVideo(result.processedBlob, file.name);
                        };
                    }
                    
                    // Add to processed videos if not already there
                    const existingIndex = processedVideos.findIndex(v => v.index === index);
                    if (existingIndex === -1) {
                        processedVideos.push({
                            index,
                            name: file.name,
                            blob: result.processedBlob
                        });
                        
                        // Update counters
                        successFilesEl.textContent = processedVideos.length;
                        processedFilesEl.textContent = parseInt(processedFilesEl.textContent) + 1;
                        remainingFilesEl.textContent = parseInt(remainingFilesEl.textContent) - 1;
                    }
                } else {
                    // Update video card with failure
                    updateVideoCardStatus(index, 'failed', 0);
                    failedFilesEl.textContent = parseInt(failedFilesEl.textContent) + 1;
                }
                
            } catch (error) {
                console.error(`Error processing video ${file.name}:`, error);
                updateVideoCardStatus(index, 'failed', 0);
                failedFilesEl.textContent = parseInt(failedFilesEl.textContent) + 1;
            }
        }
        
        function downloadAllProcessed() {
            if (processedVideos.length === 0) return;
            
            // Create a zip file in a real implementation
            // For this demo, we'll download them one by one
            processedVideos.forEach(video => {
                downloadProcessedVideo(video.blob, video.name);
            });
        }
        
        function downloadProcessedVideo(blob, originalName) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `edited_${originalName}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        // Simulation function - in a real app this would be API calls
        async function simulateVideoProcessing(file, index) {
            return new Promise((resolve) => {
                // Simulate processing time (3-8 seconds per video)
                const processingTime = 3000 + Math.random() * 5000;
                const startTime = Date.now();
                
                // Update progress periodically
                const progressInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(100, (elapsed / processingTime) * 100);
                    
                    // Update progress bar for this video
                    const progressBar = document.getElementById(`progress-${index}`);
                    if (progressBar) {
                        progressBar.style.width = `${progress}%`;
                    }
                }, 200);
                
                setTimeout(() => {
                    clearInterval(progressInterval);
                    
                    // 90% chance of success for simulation
                    const success = Math.random() > 0.1;
                    
                    if (success) {
                        // In a real app, this would be the actual processed blob from the server
                        // For simulation, we'll just use the original file
                        resolve({
                            success: true,
                            processedBlob: new Blob([file], { type: file.type })
                        });
                    } else {
                        resolve({
                            success: false,
                            error: "Processing failed (simulated)"
                        });
                    }
                }, processingTime);
            });
        }
    </script>
</body>
</html>
